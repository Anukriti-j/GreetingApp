// TODO 1: Create variables and constants

Create a variable for your age and a constant for your name

var  age: Int = 22
let  name: String = “Anukriti”

Use string interpolation to create a greeting message

print(“Hello! \(name) Welcome to Coditas.”)

// TODO 2: Work with arrays and dictionaries

Create an array of your favorite foods and a dictionary of country capitals

var  arr: [String] = [“pizza”, “cake”, “Chole bhature”]
var  dict: [String : String] =  [
	"India": "New Delhi",
	"China": "Hongkong",
	"Usa": "Washington"
]

Add a new item to the array and update a value in the dictionary

arr.append(“IceCream”)
dict["India"] = "Mumbai"
print(arr)
print(dict)

// TODO 3: Create empty collections using initializer syntax

	var array2 = Array<String> ()  // Empty Array
	var dict2 = [String:Int] ()          // Empty Dictionary
	var set = Set<Int>()


// TODO 4: Implement a function that uses if-let for optional binding

The function should take an optional string and return a greeting or default message

func optionalBinding(_ name: String?) -> String?{
  if let greeting = name{
    return "Hello, \(greeting) Good Job!"
  }else{
    return "hello Default User"
  }
}

let optionalCheck = optionalBinding(nil)
print(optionalCheck)


// TODO 5: Use a switch statement with multiple patterns
	
var status = "not pass"
switch status{
  case "pass":
  print("excellent")
  case "fail":
  print("Retry")
  default:
  print("Improve always")
}

Create a function that categorizes a number based on different ranges

func categorization(_ number : Int?){
  if let num = number {
    switch num {
    case 1...10 :
      print("number in the range 1 to 10")
    case 11...20 :
        print("number in the range 11 to 20")
    case 21... :
          print("number in the range 21 and above")
    default:
    print("range not found")
  }
  }
  else{
    print("No number found")
  }
}

Note:  use guard let instead of if let to avoid loops

func categorization(_ number : Int?){
  guard let num = number else {
    print("no number found")
    return
  }
  switch num {
    case 1...10 :
      print("number in the range 1 to 10")
    case 11...20 :
        print("number in the range 11 to 20")
    case 21... :
          print("number in the range 21 and above")
    default:
    print("range not found")
  }
}



// TODO 6: Use for-in loops with different collections

//for in with arrays

Var array = [1,4,6,3,3,2]
// using indexes

for item in 0..<4 {
  print("at \(item) array has \(array[item])")
}
// using values

for item in array{
  print(item)
}

// for- in with dictionaries

var  dict: [String : String] =  [
"India": "New Delhi",
"China": "Hongkong",
"Usa": "Washington"
]

for (country,capital) in dict{
  print(country, "-", capital)
}
// to access the keys  in dictionary

for country in dict.keys{
  print(country)
}

//to access values in dictionary

 For capital in dict.values{
print(capital)
}

// use of for-in in set

let set : Set<Int> = [2,3,1,5,7]
for item in set{
   print(item)
 }

Create a function that processes both arrays and dictionaries


func processCollection<T>(_ collection: T) {
    if let array = collection as? [Any] {
        print("Processing an array:")
        for (index, element) in array.enumerated() {
            print("Index \(index): \(element)")
        }
    } else if let dictionary = collection as? [AnyHashable: Any] {
        print("Processing a dictionary:")
        for (key, value) in dictionary {
            print("Key: \(key), Value: \(value)")
        }
    } else {
        print("Unsupported type: \(type(of: collection))")
    }
}




// TODO 7: Create a function with multiple parameters and return values
Function should calculate statistics for an array of numbers

// used nil coalescing operator to provide default values

func calculateSum(_ arrNumbers: [Int], _ count: Int)-> (Int, Int, Int, Int){
   let min = arrNumbers.min() ?? 0
   let max = arrNumbers.max() ?? 0
   var sum = 0
   for num in arrNumbers{
     sum += num
   }
let avg = sum/count
return (min, max, sum, avg)
 }
print(calculateSum([2,4,1,6,5,0], 6))

 
// TODO 8: Create a function that takes another function as parameter
Implement a function that applies an operation to each element in an array

// same function but here used guard let for optional binding

func calculateSum(_ arrNumbers: [Int], _ count: Int)-> (min: Int, max: Int, sum: Int,avg:
 Int){
   guard !arrNumbers.isEmpty else{
     return (0,0,0,0)
   }
   let min = arrNumbers.min()!
   let max = arrNumbers.max()!
   var sum = 0
   for num in arrNumbers{
     sum += num
   }
   let avg = sum/count
    return (min, max, sum, avg)
 }
print(calculateSum([2,4,1,6,5,0], 6))



// TODO 9: Create and use closures

// Creating a closure and its use as a block of functionality

let createclosure = { (_ x: Int, _ y: Int)-> Int in 
return x + y
}
print(createclosure(10,20))

// Using closures as a parameter to a function

func salary(_ fix: Int, _ incentive: Int, increment: (Int, Int)-> Int)-> Int{
  var totalSalary = increment(fix, incentive)
  return totalSalary
}

let income = salary(11000, 1500){ fix, incentive in 
  return fix + incentive
}
print(income)


Use closures with the map function and create a closure that captures values

//use closures with map function

let numbers = [2,4,5,3,5,8]

let incrementedNumbers = numbers.map({ (number) ->Int in 
 return number + 1
})
print(incrementedNumbers)

// use closure to capture values

func captureValue(_ value:Int) -> () -> Int{
  var seat = value
  var position = { ()-> Int in
  seat += 1
   return seat 
  }
  return position
}
var sitting = captureValue(10)
print(sitting())
print(sitting())




// TODO 10: Create a class with properties, methods, and inheritance

class Intern{
  var internId : Int
  var internName : String
  init(internId: Int, internName: String){
    self.internId = internId
    self.internName = internName
  }
   func mentorship(mentorName: String){
     print("I am \(internName) , my id is \(internId), my mentor is \(mentorName)")
        }
   }

var fresher = Intern(internId: 101, internName: "Anukriti")
 fresher.mentorship(mentorName: "Kinjal")

// Inheritance

class FullTime: Intern{
  func promotion(_ salary :Int){
    print("\(internId), \(internName) got promoted with salary \(salary)")
  }
}

let emp1 = FullTime(internId: 101, internName: "anukriti")
emp1.promotion(30000)



// TODO 11: Add getter and setter properties

class Intern{
  var internId : Int
  var internName : String
  init(internId: Int, internName: String){
    self.internId = internId
    self.internName = internName
  }
  //computed property to add getter and setter
  
  var internNo : Int{
    get{
      return internId + 100
    }
    set(newValue){
      internId = newValue
    }
  }
   func mentorship(mentorName: String){
     print("I am \(internName) , my id is \(internId), my mentor is \(mentorName)")
     
   }
}

var fresher = Intern(internId: 101, internName: "Anukriti")
fresher.mentorship(mentorName: "Kinjal")
print(fresher.internNo)

// TODO 12: Create an enumeration with methods and associated values

enum TechStack{
  case ios(deviceName: String)
  case android(deviceName: String)
  case experience(year: Int)
  
  func training(_ tech: TechStack){
    switch tech {
      case .ios(let name):
      print(name)
      case .android(let name):
        print(name)
      default:
      print("not working")
    }
  }
}
 let item1 = TechStack.ios(deviceName: "Macos")
 TechStack.training(item1)
 item1.training(item1)

// TODO 13: Create a structure with methods

enum TechStack{
  case ios(deviceName: String)
  case android(deviceName: String)
  case experience(year: Int)
  
  func training(_ tech: TechStack){
    switch tech {
      case .ios(let name):
      print(name)
      case .android(let name):
        print(name)
      default:
      print("not working")
    }
  }
}
 let item1 = TechStack.ios(deviceName: "Macos")
 TechStack.training(item1)
 item1.training(item1)

// TODO 14: Create a function that returns an array of cards (full deck)

enum  Num: Int, CaseIterable {
    case ace = 1, two, three, four, five, six, seven, eight, nine, ten, jack, queen, king
}

enum Suit: CaseIterable {
    case spades, hearts, diamonds, clubs
}

struct Card {
    let num: Num
    let suit: Suit
    func simpleDescription() -> String {
        "\(num) of \(suit)"
    }

    static func createDeck() -> [Card] {
        // Loop through every suit and every rank to build a 52-card deck
        var deck: [Card] = []
        for suit in Suit.allCases {
            for rank in Num.allCases {
                deck.append(Card(num: rank, suit: suit))
            }
        }
        return deck
    }
}
let fullDeck = Card.createDeck()
print(fullDeck.count) // 52


// TODO 15: Create a protocol and implement it in different types. Use mutating method
protocol Engine{
var startSpeed: Int{get set}  //property in protocol must have {get} or {get set}
func accelerate(_ speed:Int)->Int
}
// Conforming to class
class ElectricVehicle: Engine{
    var startSpeed = 0
    func accelerate(_ speed: Int)-> Int{
        return startSpeed + speed
    }
}
let ev = ElectricVehicle()
print(ev.accelerate(100))

// Conforming to Struct 

protocol Engine{
    var startSpeed: Int{get set}
    mutating func accelerate()->Int
}
struct Vehicle: Engine{
    var startSpeed = 0
    mutating func accelerate()-> Int{
    startSpeed += 100
        return startSpeed
    }
}
var veh = Vehicle()
print(veh.accelerate())

// Protocol extension
extension Engine{
     mutating func brake()-> Int{
     startSpeed -= 10
         return startSpeed
     }
 }
 print(veh.brake())



// TODO 16: Create an extension that adds functionality to an existing type

extension Int{
    func isEven()-> Bool {
     return self % 2 == 0
    }
}
let num: Int = 8
print(num.isEven())


// TODO 17: Create custom errors and functions that can throw
// TODO 18: Use do-catch to handle errors

enum NetworkError: Error{
    case internetIssue
    case invalidUrl
}
 func dataRequest(_ url: String) throws {
     if url == "" {
         throw NetworkError.internetIssue
     }
 }
 do{
     try dataRequest("")
     print("valid request")
 }catch{
     print("invalid request")
 }

// TODO 19: Use try? to convert errors to optionals

enum NetworkError: Error{
    case internetIssue
    case invalidUrl
}
 func dataRequest(_ url: String) throws {
     if url == "" {
         throw NetworkError.invalidUrl
     }
 }
 if let error = try? dataRequest(""){
     switch error as NetworkError{
         case .internetIssue:
         print("interetissue")
         case .invalidUrl:
         print("invalidUrl")
     }
 }else{
     print("success")
 }


// TODO 20: Use defer to execute cleanup code

func resources(_ file: String){
    defer{
        print("file is closed")
    }
    print(" \(file) file is open")
}
var systemUse = resources("mySwift.png")

// TODO 21: Create generic functions and types

func swapping<T>(_ val1: inout T, _ val2 : inout T){
    let a = val1
    val1 = val2
    val2 = a
}
var val1 = "Hello"
var val2 = "Hi"
var swapNum = swapping(&val1, &val2)
print(val1, val2)

// Generic Type

struct Stack<Element> {
    var collection: [Element] = []
    mutating func push(_ item: Element){
        collection.append(item)
    }

}
var stack = Stack<String>()
stack.push("Hello")
stack.push("hi")
print(stack)

Evaluation:

 TODO 19: Try with Optionals
⚠️ Minor issue:
if let error = try? dataRequest("") {
   ...
}
try? doesn't return the error. It returns nil on failure.
Use do-catch or Result if you want the error object.
TODO 12: Enums with Associated Values
✔️ Mostly correct.
Minor improvement: Instead of training(_:), define training() as an instance method only. Current setup is a bit awkward:

TechStack.training(item1) //  ✅ works
item1.training(item1) // awkward, and this won’t compile

Problem:
training(_:) is declared as a static method, but it's designed to operate on a specific instance (TechStack value).
You're passing the instance into itself: TechStack.training(item1)
Or even worse: item1.training(item1) — confusing and redundant.

Fix:
Make training() an instance method. That way, each TechStack value can call its own method directly, no need to pass itself in.
enum TechStack {
    case ios(years: Int)
    case android(years: Int)
    case flutter(years: Int)
   func training() {
        switch self {
        case .ios(let years):
            print("Training iOS for \(years) years")
        case .android(let years):
            print("Training Android for \(years) years")
        case .flutter(let years):
            print("Training Flutter for \(years) years")
        }
    }
}
Now, you can just do:
let item1 = TechStack.ios(years: 2)
item1.training()  


TODO 6: For-in Loops
✔️ Mostly good, but:
Syntax issue:

Var array = …
For capital in ...

Use var and for (Swift is case-sensitive).

